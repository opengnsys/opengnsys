#!/bin/bash
#/**
#@file    deployGitImage
#@brief   Proceso completo de despliegue de imagen, incluyendo actualización de la caché, restauración y post-configuración (este script es llamado por la interfaz RestaurarBaseImagen).
#@param   $1 Repositorio (CACHE, REPO o dirección IP)
#@param   $2 Nombre canónico de la imagen (sin extensión)
#@param   $3 Número de disco
#@param   $4 Número de particion
#@param   $5 Protocolo (Git)
#@param   $6 Opciones del protocolo str_modo_git:str_modo_acl str_modo_git=clone|checkout str_modo_acl:total|user
#@exception OG_ERR_FORMAT   1 formato incorrecto.
#@exception OG_ERR_NOTFOUND  2 fichero de imagen o partición no detectados.
#@exception OG_ERR_PARTITION 3	# Error en partición de disco.
#@exception OG_ERR_LOCKED    4 partición bloqueada por otra operación.
#@exception OG_ERR_IMAGE    5 error al restaurar la imagen del sistema.
#@exception OG_ERR_IMGSIZEPARTITION  30 Tamaño de la particion es menor al tamaño de la imagen.
#@exception OG_ERR_NOTCACHE     No existe cache -15-
#@exception OG_ERR_CACHESIZE   Tamaño de la paticion menor al archivo a descargar -16-
#@version 1.2 - primera versión basada en deployImagen y script de GIT de UGR
#@date    2020/07/07
#**/


#Descripcion:
# Si Repositorio es el global (REPO) realiza un deploy.
# Si Repositorio es local (CACHE) realiza un restoreGitImage CACHE
# El deploy, si detecta que el cliente no tiene una CACHE o no tiene espacio suficiente consulta el engine.cfg  RESTOREPROTOCOLNOCACHE



PROG="$(basename $0)"
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$PROG" "$PROG [REPO|CACHE] imagen ndisk npart GIT [clone|checkout]:[total|user]" \
           "$PROG REPO Ubuntu20 1 2 GIT clone:total" \
	   "$PROG CACHE Windows20 1 1 GIT checkout:user"
   exit 0
fi


if [ $# -lt 4 ]; then
    ogRaiseError session $OG_ERR_FORMAT "$MSG_FORMAT: $PROG REPO imagen ndisco nparticion GIT [opciones protocolo] ]"
    exit $?
fi

# El protocolo tiene que se GIT
[ "${5^^}" == "GIT" ] || ogRaiseError $OG_ERR_OUTOFLIMIT "$PROG: único protocolo permitido GIT" || exit $?

# Asignación de variables (repositorio y protocolo se convierten a mayúsculas).
TIME1=$SECONDS
REPO="${1^^}"
REPO=${REPO:-"REPO"}
IMGNAME="$2"
DISK="$3"
PART="$4"
PROTO="${5^^}"
PROTOOPT="${6:-checkout:total}"

# Unidad organizativa.
[ "$ogunit" != "" ] && OGUNIT="$ogunit"

#Load engine configurator from engine.cfg file.
#Carga el configurador del engine desde el fichero engine.cfg
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

# Clear temporary file used as log track by httpdlog
# Limpia los ficheros temporales usados como log de seguimiento para httpdlog
echo " " > $OGLOGCOMMAND
[ "$(ogGetCaller)" == "EjecutarScript" ] || echo -n "" > $OGLOGSESSION

# Registro de inicio de ejecución
ogEcho log session "[1] $MSG_SCRIPTS_START $0 $*"

# Si el origen(pariticion) esta bloqueada salir.
ogIsLocked $DISK $PART && exit $(ogRaiseError session $OG_ERR_LOCKED "$MSG_PARTITION, $DISK $PART"; echo $?)

#ogEcho log session "$MSG_HELP_ogUnmount $DISK $PART"
#ogUnmount $DISK $PART 2>/dev/null

# Valor por defecto para el repositorio.
if [ "$REPO" == "$(ogGetIpAddress)" -o "$REPO" == "CACHE" ]; then
    REPO="CACHE"
else
    ogCheckIpAddress "$REPO"
    if [ $? -eq 0 -o "$REPO" == "REPO"  ]; then
        # Si falla el cambio -> salimos con error repositorio no valido
        ogChangeRepo $REPO ${OGUNIT} || exit $(ogRaiseError $OG_ERR_NOTFOUND "$REPO $OGUNIT"; echo $?)
        REPO="REPO"
    fi
fi

# Comprobamos que existe la imagen
ogExistGitImage $REPO "$IMGNAME" || ogRaiseError log session $OG_ERR_NOTFOUND "$REPO $IMGNAME" || exit $? 

#Informacioin previa de la imagen
INFOFILE=$(ogGetPath $REPO ".$IMGNAME.img.json")
IMGSIZE=$(jq .size $INFOFILE|tr -d \")

ogEcho log session "[1] REPO=$REPO IMG-BRANCH=$IMGNAME  SIZE=$IMGSIZE (KB)"

# Procesar repositorio.
if [ $REPO == "REPO" ]; then
                ogEcho log session "[2] updateGitCache "$REPO" \"/$IMGNAME\" $PROTO $PROTOOPT"
                TIME2=$SECONDS
                updateGitCache "$REPO" "$IMGNAME" "$PROTO" "$PROTOOPT"	 	
                RETVAL=$?
                TIME2=$[SECONDS-TIME2]
                ogEcho log session "   [ ]  $MSG_SCRIPTS_TIME_PARTIAL updateGitCache $[TIME2/60]m $[TIME2%60]s"
                case $RETVAL in
                    0)
                        ogEcho log session "[50] updateGitCache (OK)"
                    ;;
                    15|16)
                        # no se permite usar la cache (no existe(15) o no espacio sufiente (16). Se consulta engine.cfg para RESTOREPROTOCOLNOCACHE [ multicast   unicast  none ]
                        ogEcho log session "[50] $MSG_ERR_NOTCACHE ;  $MSG_ERR_CACHESIZE "
                        ogEcho log session "[50] $MSG_SCRIPTS_CHECK_ENGINE:  RESTOREPROTOCOLNOTCACHE=$RESTOREPROTOCOLNOTCACHE "
                            	case $RETVAL in
                                	15)
                                    	ogEcho log session "[100] $MSG_ERR_NOTCACHE"
                                        ogRaiseError session $OG_ERR_NOTCACHE "NOT CACHE"
                                        exit $?
                                    ;;
                                    16)
                                    	ogEcho log session "[100]  $MSG_ERR_CACHESIZE "
                                    	ogRaiseError session $OG_ERR_CACHESIZE "CACHE FULL"
                                        exit $?
                                    ;;
                                esac # del segundo RETAVAL
                          	;;
		    *)
			# Error desconocido
			exit $RETVAL
		    ;;
                esac
fi

TIME3=$SECONDS

# Si existe, ejecuta script personalizado "restoreImageCustom"; si no, llama al genérico "restoreImage".
if which restoreGitImageCustom &>/dev/null; then
    ogEcho log session "[55] $MSG_HELP_ogRestoreGitImage: restoreGitImageCustom CACHE \"$IMGNAME\" $DISK $PART $PROTO $PROTOOPT"
    restoreGitImageCustom "$IMGNAME" $DISK $PART $PROTO $PROTOOPT
else
    ogEcho log session "[55] $MSG_HELP_ogRestoreGitImage: restoreGitImage CACHE \"$IMGNAME\" $DISK $PART $PROTO $PROTOOPT"
    restoreGitImage CACHE "$IMGNAME" $DISK $PART $PROTO $PROTOOPT
fi
RETVAL=$?

# Mostrar resultados.
RESUMERESTOREIMAGE=$(grep -m 1 "Total Time:" $OGLOGCOMMAND)
ogEcho log session "   [ ]      $RESUMERESTOREIMAGE "
# Si la transferencia ha dado error me salgo.
if [ $RETVAL -ne 0 ] ; then
    ogRaiseError session $OG_ERR_IMAGE "$REPO $IMGNAME" 2>&1
    # Muestro registro de fin de ejecución si no viene de Ejecutar Script
    [ "$(ogGetCaller)" == "EjecutarScript" ] || ogEcho log session "$MSG_INTERFACE_END $OG_ERR_IMAGE"
    exit $OG_ERR_IMAGE
fi
TIME3=$[SECONDS-TIME3]
ogEcho log session "   [ ]      $MSG_SCRIPTS_TIME_PARTIAL : $[TIME3/60]m $[TIME3%60]s"

# Si existe, ejecuta script personalizado de postconfiguración "configureOsCustom"; si no, llama al genérico "configureOs".
if which configureOsCustom &>/dev/null; then
    ogEcho log session "[90] configureOsCustom"
    configureOsCustom "$DISK" "$PART" "$REPO" "$IMGNAME"
else
    ogEcho log session "[90] $MSG_SCRIPTS_OS_CONFIGURE "
    configureOs "$DISK" "$PART"
fi

TIME=$[SECONDS-TIME1]
ogEcho log session "[100] $MSG_SCRIPTS_TIME_TOTAL $[TIME/60]m $[TIME%60]s"

# Registro de fin de ejecución
# Si se ha llamado desde ejecutar script no lo muestro para no repetir.
if [ "$(ogGetCaller)" != "EjecutarScript" ] ; then
    ogEcho log session "$MSG_INTERFACE_END $RETVAL"
    exit $RETVAL
fi
